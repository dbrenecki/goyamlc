package cmd

import (
	"bufio"
	"errors"
	"fmt"
	"go/ast"
	"os"
	"slices"
	"strings"

	"github.com/dbrenecki/goyamlc/pkg/util"

	"github.com/rs/zerolog/log"
)

func createStructsForYaml(rootStructs []string, f *ast.File) (err error) {
	file, err := os.Create("../test/data/example.yaml")

	defer func() {
		if tempErr := file.Close(); tempErr != nil && err == nil {
			err = tempErr
		}
	}()

	w := bufio.NewWriter(file)

	_, err = w.WriteString("---\n# autogenerated by github.com/dbrenecki/goyamlc do not edit.\n#\n")
	if err != nil {
		return err
	}

	isArr := util.PtrTo(false)
	for _, name := range rootStructs {
		if err := walkStructFields(0, name, w, f.Decls[:], isArr); err != nil {
			return err
		}
	}

	if err := w.Flush(); err != nil {
		return err
	}
	return nil
}

func walkStructFields(indentCount int, name string, w *bufio.Writer, decls []ast.Decl, isArr *bool) error {
	for i, decl := range decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			log.Debug().Msgf(`ast.Decl: "%T" is not of "*ast.Decl" type, skipping`, decl)
			_ = ok
			continue
		}

		var typeSpec *ast.TypeSpec

		for _, s := range genDecl.Specs {
			typeSpec, ok = s.(*ast.TypeSpec)
			if !ok {
				log.Debug().Msgf(`ast.Spec type "%T" is not a "*ast.TypeSpec", skipping`, decl)
				continue
			}
			if typeSpec.Name.Name != name {
				continue
			}
		}

		fmt.Println("SECOND isArr", *isArr)
		fmt.Println("typespec", typeSpec)
		if typeSpec == nil {
			continue
		}
		fmt.Println("tyename", typeSpec.Name.Name, name)

		// write struct comment
		if genDecl.Doc != nil {
			for _, c := range genDecl.Doc.List {
				fmt.Println("COMMENT", c)
				if err := writeComment(indentCount, c, w); err != nil {
					return err
				}
			}
		}

		fmt.Println("inside walkstruct", *isArr)
		_, err := w.WriteString(formatCamelCase(isArr, indentCount, typeSpec.Name.Name) + ":\n")
		if err != nil {
			return err
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			log.Debug().Msgf(`ast.TypeSpec: "%T" is not of "*ast.StrucType" type, skipping`, structType)
			return errors.New("somethign EWNWT WRONG")
		}

		fields := structType.Fields.List

		indentCount += 2
		for _, field := range fields {
			if field.Doc != nil {
				for _, c := range field.Doc.List {
					// write field comment
					if err = writeComment(indentCount, c, w); err != nil {
						return err
					}
				}
			}

			switch t := field.Type.(type) {
			case *ast.Ident:
				if t.Obj != nil {
					newDecls := decls[:]
					fmt.Println("Deleting decl", newDecls[i])
					newDecls = slices.Delete(newDecls, i, i+1)

					if err = walkStructFields(indentCount, field.Names[0].Name, w, newDecls, isArr); err != nil {
						return err
					}
				} else {
					if !ok {
						log.Debug().Msgf(`ast.Expr: "%T" is not a "*ast.Ident", skipping`, field.Type)
						continue
					}

					_, err = w.WriteString(formatCamelCase(isArr, indentCount, field.Names[0].Name) + ": " + t.Name + "\n")
					if err != nil {
						return err
					}
				}
			case *ast.MapType:
				identKey, ok := t.Key.(*ast.Ident)
				if !ok {
					return errors.New("map keys should always have ident types")
				}
				identValue, ok := t.Value.(*ast.Ident)
				if !ok {
					return errors.New("map values should always have ident types")
				}
				_, err = w.WriteString(
					formatCamelCase(isArr, indentCount, field.Names[0].Name) + ": " + "map[" + identKey.Name + "]" + identValue.Name + "\n")
				if err != nil {
					return err
				}
			case *ast.ArrayType:
				identElt, ok := t.Elt.(*ast.Ident)
				if !ok {
					return errors.New("array types should always have ident types")
				}

				if identElt.Obj == nil {
					_, err = w.WriteString(
						formatCamelCase(isArr, indentCount, field.Names[0].Name) + ":\n" + "array of " + identElt.Name + "\n")
					if err != nil {
						return err
					}
				} else {
					newDecls := decls[:]
					fmt.Println("Deleting decl", newDecls[i])
					newDecls = slices.Delete(newDecls, i, i+1)
					*isArr = true
					fmt.Println("isArr", *isArr)
					walkStructFields(indentCount, field.Names[0].Name, w, newDecls, isArr)
					*isArr = false
				}
			}
		}
	}
	return nil
}

func writeComment(indentCount int, astCmt *ast.Comment, w *bufio.Writer) error {
	cmt := strings.Replace(astCmt.Text, "//", "#", 1)
	_, err := w.WriteString(strings.Repeat(" ", indentCount) + cmt + "\n")
	if err != nil {
		return err
	}
	return nil
}
