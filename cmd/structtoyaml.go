package cmd

import (
	"bufio"
	"errors"
	"go/ast"
	"os"
	"slices"
	"strings"

	"github.com/rs/zerolog/log"

	"github.com/dbrenecki/goyamlc/pkg/util"
)

type formatWriter struct {
	*bufio.Writer
	indentCount int
}

func createStructsForYaml(rootStructs []string, f *ast.File) (err error) {
	// TODO: this should be cobra input
	file, err := os.Create("../test/data/example.yaml")

	defer func() {
		if tempErr := file.Close(); tempErr != nil && err == nil {
			err = tempErr
		}
	}()

	w := formatWriter{
		Writer: bufio.NewWriter(file),
	}

	_, err = w.WriteString("---\n# autogenerated by github.com/dbrenecki/goyamlc do not edit.\n#\n")
	if err != nil {
		return err
	}

	isArr := util.PtrTo(false)
	for _, name := range rootStructs {
		if err := w.walkAst(name, f.Decls[:], isArr); err != nil {
			return err
		}
	}

	if err := w.Flush(); err != nil {
		return err
	}
	return nil
}

// walkAst recursively walks the Abstract Syntax Tree
func (w formatWriter) walkAst(name string, decls []ast.Decl, isArr *bool) error {
	for i, decl := range decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			log.Debug().Msgf(`ast.Decl: "%T" is not of "*ast.Decl" type, skipping`, decl)
			_ = ok
			continue
		}

		var typeSpec *ast.TypeSpec

		for _, s := range genDecl.Specs {
			typeSpec, ok = s.(*ast.TypeSpec)
			if !ok {
				log.Debug().Msgf(`ast.Spec type "%T" is not a "*ast.TypeSpec", skipping`, decl)
				continue
			}
			if typeSpec.Name.Name != name {
				continue
			}
		}

		if typeSpec == nil {
			continue
		}

		// write struct comment
		if genDecl.Doc != nil {
			for _, c := range genDecl.Doc.List {
				if err := w.writeComment(c); err != nil {
					return err
				}
			}
		}

		_, err := w.WriteString(w.formatCamelCase(isArr, typeSpec.Name.Name) + ":\n")
		if err != nil {
			return err
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			log.Debug().Msgf(`ast.TypeSpec: "%T" is not of "*ast.StrucType" type, skipping`, structType)
			// TODO: rm
			return errors.New("somethign EWNWT WRONG")
		}

		fields := structType.Fields.List

		w.indentCount += 2
		for _, field := range fields {
			if field.Doc != nil {
				for _, c := range field.Doc.List {
					// write field comment
					if err = w.writeComment(c); err != nil {
						return err
					}
				}
			}

			switch t := field.Type.(type) {
			case *ast.Ident:
				if t.Obj != nil {
					newDecls := decls[:]
					newDecls = slices.Delete(newDecls, i, i+1)

					if err = w.walkAst(field.Names[0].Name, newDecls, isArr); err != nil {
						return err
					}
				} else {
					if !ok {
						log.Debug().Msgf(`ast.Expr: "%T" is not a "*ast.Ident", skipping`, field.Type)
						continue
					}

					_, err = w.WriteString(w.formatCamelCase(isArr, field.Names[0].Name) + ": " + t.Name + "\n")
					if err != nil {
						return err
					}
				}
			case *ast.MapType:
				identKey, ok := t.Key.(*ast.Ident)
				if !ok {
					return errors.New("map keys should always have ident types")
				}
				identValue, ok := t.Value.(*ast.Ident)
				if !ok {
					return errors.New("map values should always have ident types")
				}
				_, err = w.WriteString(
					w.formatCamelCase(isArr, field.Names[0].Name) + ": " + "map[" + identKey.Name + "]" + identValue.Name + "\n")
				if err != nil {
					return err
				}
			case *ast.ArrayType:
				identElt, ok := t.Elt.(*ast.Ident)
				if !ok {
					return errors.New("array types should always have ident types")
				}

				if identElt.Obj == nil {
					_, err = w.WriteString(
						w.formatCamelCase(
							isArr, field.Names[0].Name) + ":\n" + strings.Repeat(" ", w.indentCount+2) + "- " + identElt.Name + "\n")
					if err != nil {
						return err
					}
				} else {
					newDecls := decls[:]
					newDecls = slices.Delete(newDecls, i, i+1)
					*isArr = true
					if err = w.walkAst(field.Names[0].Name, newDecls, isArr); err != nil {
						return err
					}
					*isArr = false
				}
			}
		}
	}
	return nil
}

func (w formatWriter) formatCamelCase(isArr *bool, s string) string {
	// TODO: dash formatting should NOT be included here.
	dash := ""
	if *isArr {
		dash = "- "
		*isArr = false
	}
	return strings.Repeat(" ", w.indentCount) + dash + strings.ToLower(s[:1]+s[1:])
}

func (w formatWriter) writeComment(astCmt *ast.Comment) error {
	cmt := strings.Replace(astCmt.Text, "//", "#", 1)
	_, err := w.WriteString(strings.Repeat(" ", w.indentCount) + cmt + "\n")
	if err != nil {
		return err
	}
	return nil
}
