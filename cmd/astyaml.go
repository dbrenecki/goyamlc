package cmd

import (
	"bufio"
	"errors"
	"fmt"
	"go/ast"
	"os"
	"slices"
	"strings"

	"github.com/rs/zerolog/log"

	"github.com/dbrenecki/goyamlc/pkg/util"
)

const autogenAuthorComment = "---\n# autogenerated by github.com/dbrenecki/goyamlc do not edit.\n#\n"

type formatWriter struct {
	*bufio.Writer
	indentCount int
}

func createStructsForYaml(rootStructs []string, f *ast.File) (err error) {
	// TODO: this should be cobra input
	file, err := os.Create("../test/data/example.yaml")

	defer func() {
		if tempErr := file.Close(); tempErr != nil && err == nil {
			err = tempErr
		}
	}()

	w := formatWriter{
		Writer: bufio.NewWriter(file),
	}

	_, err = w.WriteString(autogenAuthorComment)
	if err != nil {
		return err
	}

	isArr := util.PtrTo(false)
	for _, name := range rootStructs {
		if err := w.walkAst(name, f.Decls[:], isArr); err != nil {
			return err
		}
	}

	if err := w.Flush(); err != nil {
		return err
	}
	return nil
}

// walkAst recursively walks the Abstract Syntax Tree
func (w formatWriter) walkAst(name string, decls []ast.Decl, isArr *bool) error {
	var err error
	for i, decl := range decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			// skips non "*ast.GenDecl" types
			_ = ok
			continue
		}

		var typeSpec *ast.TypeSpec
		for _, s := range genDecl.Specs {
			typeSpec, ok = s.(*ast.TypeSpec)
			if !ok {
				// skips non "*ast.TypeSpec" types
				continue
			}
			if typeSpec.Name.Name != name {
				continue
			}
		}

		if typeSpec == nil || typeSpec.Name.Name != name {
			// skips non matching "*TypeSpec.Name.Name" in this ast.GenDecl
			continue
		}

		// write struct comment
		if genDecl.Doc != nil {
			for _, c := range genDecl.Doc.List {
				if err := w.writeComment(c); err != nil {
					return err
				}
			}
		}

		if err = w.writeField(typeSpec.Name.Name, "", isArr); err != nil {
			return err
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			// this should not run as the assumption is that it will always be a struct type
			return fmt.Errorf(`"%T" is not an "*ast.StructType"`, typeSpec.Type)
		}

		w.indentCount += 2
		for _, field := range structType.Fields.List {
			if field.Doc != nil {
				for _, c := range field.Doc.List {
					// write field comment
					if err = w.writeComment(c); err != nil {
						return err
					}
				}
			}

			switch t := field.Type.(type) {
			case *ast.Ident:
				if t.Obj != nil {
					newDecls := decls[:]
					newDecls = slices.Delete(newDecls, i, i+1)

					if err = w.walkAst(field.Names[0].Name, newDecls, isArr); err != nil {
						return err
					}
				} else {
					if !ok {
						log.Debug().Msgf(`ast.Expr: "%T" is not a "*ast.Ident", skipping`, field.Type)
						continue
					}

					if err = w.writeField(field.Names[0].Name, t.Name, isArr); err != nil {
						return err
					}
				}
			case *ast.MapType:
				identKey, ok := t.Key.(*ast.Ident)
				if !ok {
					return errors.New("map keys should always have ident types")
				}
				identValue, ok := t.Value.(*ast.Ident)
				if !ok {
					return errors.New("map values should always have ident types")
				}

				if err = w.writeField(field.Names[0].Name, "map["+identKey.Name+"]"+identValue.Name, isArr); err != nil {
					return err
				}
			case *ast.ArrayType:
				identElt, ok := t.Elt.(*ast.Ident)
				if !ok {
					return errors.New("array types should always have ident types")
				}

				if identElt.Obj == nil {
					if err = w.writeField(field.Names[0].Name, identElt.Name, isArr); err != nil {
						return err
					}
				} else {
					newDecls := decls[:]
					newDecls = slices.Delete(newDecls, i, i+1)
					*isArr = true
					if err = w.walkAst(field.Names[0].Name, newDecls, isArr); err != nil {
						return err
					}
					*isArr = false
				}
			}
		}
	}
	return nil
}

func (w formatWriter) formatCamelCase(s string) string {
	camelWindow := 1
	indentCount := w.indentCount
	if len(s) > 0 && s[0] == '-' {
		camelWindow = 3
		indentCount += 2
	}
	return strings.Repeat(" ", indentCount) + strings.ToLower(s[:camelWindow]+s[camelWindow:])
}

// writeComment converts a golang comment to a yaml comment and writes to the buffer.
func (w formatWriter) writeComment(astCmt *ast.Comment) error {
	golangCmt := "//"
	if !strings.HasPrefix(astCmt.Text, golangCmt) {
		return fmt.Errorf("ast comment does not start with %#v", golangCmt)
	}
	cmt := strings.Replace(astCmt.Text, golangCmt, "#", 1)
	_, err := w.WriteString(strings.Repeat(" ", w.indentCount) + cmt + "\n")
	if err != nil {
		return err
	}
	return nil
}

func (w formatWriter) writeField(name string, typeName string, isArr *bool) error {
	if *isArr {
		name = "- " + name
		*isArr = false
	}

	_, err := w.WriteString(w.formatCamelCase(name) + ": " + typeName + "\n")
	if err != nil {
		return err
	}
	return nil
}
