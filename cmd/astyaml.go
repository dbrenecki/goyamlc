package cmd

import (
	"bufio"
	"errors"
	"fmt"
	"go/ast"
	"os"
	"strings"

	"github.com/dbrenecki/goyamlc/pkg/util"
)

const autogenAuthorComment = "---\n# autogenerated by github.com/dbrenecki/goyamlc do not edit.\n#\n"

type formatWriter struct {
	*bufio.Writer
	indentCount int
}

func createStructsForYaml(rootStructs []string, f *ast.File, path string) (err error) {
	file, err := os.Create(path)

	defer func() {
		if tempErr := file.Close(); tempErr != nil && err == nil {
			err = tempErr
		}
	}()

	w := formatWriter{
		Writer: bufio.NewWriter(file),
	}

	_, err = w.WriteString(autogenAuthorComment)
	if err != nil {
		return err
	}

	isArr := util.PtrTo(false)
	for _, name := range rootStructs {
		if err := w.walkDecl(name, f.Decls, isArr); err != nil {
			return err
		}
	}

	if err := w.Flush(); err != nil {
		return err
	}
	return nil
}

// walkDecl recursively walks the Decl Abstract Syntax Tree removing previously
// traversed nodes as part of each recursion.
func (w formatWriter) walkDecl(name string, decls []ast.Decl, isArr *bool) error {
	var err error
	for _, decl := range decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			// skips non "*ast.GenDecl" types
			_ = ok
			continue
		}

		var typeSpec *ast.TypeSpec
		for _, s := range genDecl.Specs {
			typeSpec, ok = s.(*ast.TypeSpec)
			if !ok {
				// skips non "*ast.TypeSpec" types
				continue
			}
			if typeSpec.Name.Name != name {
				continue
			}
		}

		if typeSpec == nil || typeSpec.Name.Name != name {
			// skips non matching "*TypeSpec.Name.Name" in this ast.GenDecl
			continue
		}

		// write struct comment
		if genDecl.Doc != nil {
			for _, c := range genDecl.Doc.List {
				if err := w.writeComment(c); err != nil {
					return err
				}
			}
		}

		str := w.formatCamelCase(typeSpec.Name.Name) + ": " + "\n"
		_, err = w.WriteString(str)
		if err != nil {
			return err
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			// this should not run as the assumption is that it will always be a struct type
			return fmt.Errorf(`"%T" is not an "*ast.StructType"`, typeSpec.Type)
		}

		if err = w.walkTypeSpec(structType.Fields.List); err != nil {
			return err
		}

	}
	return nil
}

func (w formatWriter) walkTypeSpec(fields []*ast.Field) error {
	var err error
	w.indentCount += 2
	for _, field := range fields {
		if field.Doc != nil {
			for _, c := range field.Doc.List {
				// write field comment
				if err = w.writeComment(c); err != nil {
					return err
				}
			}
		}

		switch t := field.Type.(type) {
		case *ast.Ident:
			if t.Obj != nil {
				str := w.formatCamelCase(field.Names[0].Name) + ": " + "\n"
				_, err = w.WriteString(str)
				if err != nil {
					return err
				}

				typeSpec, ok := t.Obj.Decl.(*ast.TypeSpec)
				if !ok {
					return fmt.Errorf(`"%T" is not a "*ast.TypeSpec" type`, t.Obj.Decl)
				}
				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					return fmt.Errorf(`"%T" is not a "*ast.StructType" type`, typeSpec.Type)
				}
				fields := structType.Fields.List
				if err = w.walkTypeSpec(fields); err != nil {
					return err
				}
			} else {
				str := w.formatCamelCase(field.Names[0].Name) + ": " + t.Name + "\n"
				_, err = w.WriteString(str)
				if err != nil {
					return err
				}
			}
		case *ast.MapType:
			identKey, ok := t.Key.(*ast.Ident)
			if !ok {
				return errors.New("map keys should always have ident types")
			}
			identValue, ok := t.Value.(*ast.Ident)
			if !ok {
				return errors.New("map values should always have ident types")
			}

			str := w.formatCamelCase(field.Names[0].Name) + ": " + "map[" + identKey.Name + "]" + identValue.Name + "\n"
			_, err = w.WriteString(str)
			if err != nil {
				return err
			}
		case *ast.ArrayType:
			identElt, ok := t.Elt.(*ast.Ident)
			if !ok {
				return errors.New("array types should always have ident types")
			}

			if identElt.Obj == nil {
				str := w.formatCamelCase(field.Names[0].Name) + ":\n" + strings.Repeat(" ", w.indentCount+2) + "- " + identElt.Name + "\n"
				_, err = w.WriteString(str)
				if err != nil {
					return err
				}
			} else {
				ident, ok := t.Elt.(*ast.Ident)
				if !ok {
					return fmt.Errorf(`"%T" is not a "*ast.Ident" type`, t.Elt)
				}
				typeSpec, ok := ident.Obj.Decl.(*ast.TypeSpec)
				if !ok {
					return fmt.Errorf(`"%T" is not a "*ast.TypeSpec" type`, ident.Obj.Decl)
				}
				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					return fmt.Errorf(`"%T" is not a "*ast.StructType" type`, typeSpec.Type)
				}

				str := w.formatCamelCase(field.Names[0].Name) + ": " + "\n"
				_, err := w.WriteString(str)
				if err != nil {
					return err
				}
				if err = w.walkTypeSpec(structType.Fields.List); err != nil {
					return err
				}
			}
		}
	}
	return nil
}
